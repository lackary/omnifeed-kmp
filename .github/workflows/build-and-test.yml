name: Build and Test

on:
  push:
    branches:
      - main
    paths:
      - '.github/workflows/**'
      - 'composeApp/**'
      - 'iosApp/**'
      - 'gradle/**'
      - 'modules/**'
      - 'build.gradle.kts'
      - 'settings.gradle.kts'
      - 'package.json'

  pull_request:
    branches:
      - '*'
    paths:
      - '.github/workflows/**'
      - 'composeApp/**'
      - 'iosApp/**'
      - 'gradle/**'
      - 'modules/**'
      - 'build.gradle.kts'
      - 'settings.gradle.kts'
      - 'package.json'

  workflow_dispatch:
    inputs:
      enable_kotlin_daemon:
        description: 'Enable Kotlin/Native Daemon for build'
        type: boolean
        required: false
        default: false

      run_with_stacktrace:
        description: 'Run Gradle with --stacktrace'
        type: boolean
        required: false
        default: false

      run_with_info:
        description: 'Run Gradle with --info'
        type: boolean
        required: false
        default: false

      run_with_debug:
        description: 'Run Gradle with --debug'
        type: boolean
        required: false
        default: false

jobs:
  build-and-test:
    name: build and test
    runs-on: macos-latest
    env:
      UNSPLASH_ACCESS_KEY: ${{ secrets.UNSPLASH_ACCESS_KEY }}
      UNSPLASH_SECRET_KEY: ${{ secrets.UNSPLASH_SECRET_KEY }}
      GOOGLE_SERVICES_WEB_CLIENT_ID: ${{ secrets.GOOGLE_SERVICES_WEB_CLIENT_ID }}
    permissions:
      contents: read
    outputs: # Optional, if subsequent jobs need to know if the tests were successful
      test_outcome: ${{ steps.run_tests.outcome }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

#      - name: Cache Gradle packages
#        uses: actions/cache@v3
#        with:
#          path: |
#            ~/.gradle/caches
#            ~/.gradle/wrapper
#          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
#          restore-keys: |
#            ${{ runner.os }}-gradle-

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Create Dynamic Secrets XConfig File
        working-directory: './iosApp/Configuration'
        # Create your .xconfig file (the name must match what Xcode expects to read)
        # Write GIDClientID (corresponding to CLIENT_ID)
        # Write CFBundleURLSchemes (corresponding to REVERSED_CLIENT_ID)
        run: |
          XCONFIG_DEBUG_FILENAME="Secrets-Debug.xconfig"
          XCONFIG_RELEASE_FILENAME="Secrets-Release.xconfig"

          echo "Creating ${XCONFIG_DEBUG_FILENAME} in CI..."
          echo "Creating ${XCONFIG_RELEASE_FILENAME} in CI..."
          
          echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" > "${XCONFIG_DEBUG_FILENAME}"
          echo "REVERSE_CLIENT_ID=${{ secrets.GOOGLE_REVERSED_CLIENT_ID }}" >> "${XCONFIG_DEBUG_FILENAME}"
          echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" > "${XCONFIG_RELEASE_FILENAME}"
          echo "REVERSE_CLIENT_ID=${{ secrets.GOOGLE_REVERSED_CLIENT_ID }}" >> "${XCONFIG_RELEASE_FILENAME}"

#      - name: Create gradle.properties
#        run: |
#          echo "android.useAndroidX=true" >> gradle.properties
#          echo "org.gradle.caching=true" >> gradle.properties
#          echo "org.gradle.jvmargs=-Xmx8192M" >> gradle.properties
#          echo "kotlin.native.cacheKind.iosSimulatorArm64=none" >> gradle.properties

#      - name: Resolve Swift Package Manager Dependencies
#        working-directory: './iosApp'
#        # Execute a basic Xcode build command to download, parse, and prepare SPM dependencies.
#        # Use '-target' or '-scheme' to specify your main application target/scheme.
#        # Typically, the target/scheme name is the same as your iOS application folder name (e.g., iosApp).
#        # The '-resolvePackageDependencies' command instructs Xcode to download all SPM dependencies.
#        # This command makes Xcode download all SPM dependencies.
#        # Perform a Clean Build targeting the iOS simulator.
#        # This step generates the build output path for SPM dependencies.
#        run: |
#          echo "Resolving SPM dependencies via xcodebuild..."
#          xcodebuild -resolvePackageDependencies -project "iosApp.xcodeproj" -scheme "iosApp"

#      - name: Pre-build iOS Target to generate SPM Frameworks
#        working-directory: './iosApp'
#        # The xcodebuild clean build command forces the compilation of SPM dependencies
#        # and sets environment variables like BUILT_PRODUCTS_DIR.
#        run: |
#          echo "Resolving SPM dependencies and generating Frameworks..."
#          xcodebuild clean build \
#              -project "iosApp.xcodeproj" \
#              -scheme "iosApp" \
#              -configuration "Debug" \
#              -sdk iphonesimulator \
#              -destination "platform=iOS Simulator,name=iPhone 16 Pro Max"

      - name: Gradle Build to Generate KMP Framework
        # Run assemble to ensure all targets (including the iOS framework) are compiled
        run: |
          ./gradlew assemble \
              ${{ inputs.run_with_stacktrace && '--stacktrace' || '' }} \
              ${{ inputs.run_with_info && '--info' || '' }} \
              ${{ inputs.run_with_debug && '--debug' || '' }} \
              ${{ inputs.enable_kotlin_daemon && '-Pkotlin.native.enableDaemon=true' || '' }}

      - name: Generate Dummy Framework for CocoaPods
        run: ./gradlew :composeApp:generateDummyFramework

      - name: Install CocoaPods Dependencies
        # Make sure you have a Podfile in your iosApp directory
        # Use `gem install cocoapods` to ensure the CocoaPods environment is available
        # Run `pod install`, which will generate the Pods/ directory and the .xcworkspace file
        working-directory: './iosApp'
        run: |
          echo "Installing CocoaPods dependencies..."
          gem install cocoapods 
          pod install

      # ✅ List simulators
      - name: List available simulators
        run: |
          echo "=== RUNTIMES ==="
          xcrun simctl list runtimes
          echo "=== DEVICES ==="
          xcrun simctl list devices

      # ✅ Automatically find an available simulator (prioritize iPhone / Booted / Available)
      - name: Select an available simulator
        id: find-sim
        run: |
          set -e

          SIM=$(xcrun simctl list devices | \
            grep -E "iPhone" | \
            grep -v unavailable | \
            grep -v "(Booted)" | \
            sed -nE 's/.*\(([0-9A-F-]{36})\).*/\1/p' | \
            head -n 1)

          if [ -z "$SIM" ]; then
            echo "❌ No available iPhone simulators found"
            exit 1
          fi

          echo "✅ Selected Simulator: $SIM"
          echo "SIM=$SIM" >> $GITHUB_ENV

      - name: Xcode Build (clean build .xcworkspace)
        working-directory: './iosApp'
        run: |
          echo "Building iOS target via .xcworkspace..."
          xcodebuild clean build \
              -workspace "iosApp.xcworkspace" \
              -scheme "iosApp" \
              -configuration "Debug" \
              -sdk iphonesimulator \
              -destination "id=$SIM" \
              ENABLE_PREVIEWS=NO

      - name: Run KMP Unit Tests
        # -Pskip.tests
        # Because the test APIs of Compose Multiplatform is still Experimental.
        run: |
          ./gradlew clean
          ./gradlew :modules:unsplash-api-client:generateMockData
          ./gradlew check \
              -Pskip.tests=true \
              -Pskip.native.tests=true \
              -Pskip.lint=true \
              ${{ inputs.run_with_stacktrace && '--stacktrace' || '' }} \
              ${{ inputs.run_with_info && '--info' || '' }} \
              ${{ inputs.run_with_debug && '--debug' || '' }} \
              ${{ inputs.enable_kotlin_daemon && '-Pkotlin.native.enableDaemon=true' || '' }}

      - name: Upload Test Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports # Name of the Artifact
          path: '**/build/test-results/**/*.xml'
          retention-days: 1 # Optional, set the artifact retention time

#      - name: Test Reporter
#        uses: dorny/test-reporter@v1
#        if: always() # success() || failure() # Run on success or failure
#        with:
#          name: Test Results
#          path: '**/build/test-results/**/*.xml' # Path to JUnit XML reports
#          reporter: java-junit # Select based on report format
#          token: ${{secrets.GITHUB_TOKEN}}

  report-test-results:
    name: report test results
    runs-on: ubuntu-latest # The report job can use a different OS if needed
    needs: build-and-test # Ensures this runs after build-and-test is complete
#    permissions: # Ensures the report job has permissions to create check runs
#      checks: write
    if: always() # Always run the report job, even if build-and-test fails (dorny/test-reporter can report failures)
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Test Reports
        uses: actions/download-artifact@v4
        with:
          name: test-reports # Same as the artifact name used for uploading
          path: downloaded-test-reports # Download to a specified directory

      - name: Test Reporter
        uses: dorny/test-reporter@v1
        with:
          name: test results
          path: 'downloaded-test-reports/**/*.xml' # Point to the downloaded report path
          reporter: java-junit
          token: ${{ secrets.GITHUB_TOKEN }} # Point to the downloaded report path
          # fail-on-error: true # Set as needed; if build-and-test has already failed, you might not need this to fail again
